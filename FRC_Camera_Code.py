from cscore import CameraServer, UsbCamera
from networktables import NetworkTables, NetworkTablesInstance
import ntcore
import cv2
import numpy as np
import json
import logging
import time
from math import tan

logging.basicConfig(level=logging.DEBUG)

netTable = NetworkTablesInstance.getDefault()
netTable.startClientTeam(1860)

netTableCalibracao = netTable.getEntry("/CALIBRACAO")
netTableDistance = netTable.getEntry("/Distance")
netTableHue = netTable.getEntry("/Camera/Hue")
netTableSaturation = netTable.getEntry("/Camera/Saturation")
netTableValue = netTable.getEntry("/Camera/Value")
netTableFocalLength = netTable.getEntry("/Camera/FocalLength")
netTableCameraHeight = netTable.getEntry("/Camera/Height")
netTableCameraBrightness = netTable.getEntry("/Camera/Brightness")
netTableCameraExposure = netTable.getEntry("/Camera/Exposure")
netTableDistanceParameters = netTable.getEntry("/Camera/DistanceParameters")

CALIBRACAO = netTableCalibracao.getBoolean(1)
focalLength = netTableFocalLength.getDouble(380.191176*2)
cameraHeight = netTableCameraHeight.getDouble(1)
brightness = netTableCameraBrightness.getDouble(4)
exposure = netTableCameraExposure.getDouble(4)
distanceParameters = netTableDistanceParameters.getDoubleArray([0,0,0])

total = 1
achou = 1

class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """
        """initializes all values to presets or None if need to be set
        """
        self.__hsv_threshold_hue = [0.0, 180.0]
        self.__hsv_threshold_saturation = [123.83093415833206, 255.0]
        self.__hsv_threshold_value = [155.93524851816161, 249.197957751694]
        self.getHSVParameters()
        self.hsv_threshold_output = None

        self.__find_contours_input = self.hsv_threshold_output
        self.__find_contours_external_only = False #Vamos tentar usar como True, talvez ajude

        self.find_contours_output = None

        self.__filter_contours_contours = self.find_contours_output
        self.__filter_contours_min_area = 1000
        self.__filter_contours_min_perimeter = 0.0
        self.__filter_contours_min_width = 100.0
        self.__filter_contours_max_width = 700.0
        self.__filter_contours_min_height = 50.0
        self.__filter_contours_max_height = 400.0
        self.__filter_contours_solidity = [0.0, 100.0]
        self.__filter_contours_max_vertices = 10000.0
        self.__filter_contours_min_vertices = 0.0
        self.__filter_contours_min_ratio = 0.0
        self.__filter_contours_max_ratio = 1000.0
        # vamos mexer nessa galera pra ver se fica bom, serio parece ajudar

        self.filter_contours_output = None

    def getHSVParameters(self):
        try:
            # First we will try to get hsv parameters from networktables
            self.__hsv_threshold_hue = netTableHue.getDoubleArray([0, 0])
            self.__hsv_threshold_saturation = netTableSaturation.getDoubleArray([0, 0])
            self.__hsv_threshold_value = netTableValue.getDoubleArray([0, 0])
            if self.__hsv_threshold_hue == [0, 0] and self.__hsv_threshold_saturation == [0, 0] and self.__hsv_threshold_value == [0, 0]:
                # Probably we are not using values from networktables, so let's take them from the internal json
                with open('parameters.json', 'r') as f:
                    parameters_dict = json.load(f)
                self.__hsv_threshold_hue = parameters_dict['hue']
                self.__hsv_threshold_saturation = parameters_dict['sat']
                self.__hsv_threshold_value = parameters_dict['val']
        except:
            print("Error HSV parameters")

    

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step HSV_Threshold0:
        self.__hsv_threshold_input = source0
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)
        # Step Find_Contours0:
        self.__find_contours_input = self.hsv_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)
        

        # Step Filter_Contours0:
        self.__filter_contours_contours = self.find_contours_output
        (self.filter_contours_output) = self.__filter_contours(self.__filter_contours_contours, self.__filter_contours_min_area, self.__filter_contours_min_perimeter, self.__filter_contours_min_width, self.__filter_contours_max_width, self.__filter_contours_min_height, self.__filter_contours_max_height, self.__filter_contours_solidity, self.__filter_contours_max_vertices, self.__filter_contours_min_vertices, self.__filter_contours_min_ratio, self.__filter_contours_max_ratio)
        
        baseImage = source0
        cv2.drawContours(baseImage, self.filter_contours_output, -1, (0,255,0), 3)
        #obtain the first 2 points of contours
        cntx1 = self.filter_contours_output
        cntx = self.filter_contours_output
        global total
        global achou
        total += 1
        try:
            c = cntx[0]
            extLeft = tuple(c[c[:, :, 0].argmin()][0])
            cv2.circle(baseImage, extLeft, 7, (0, 0, 255), 5)
            extRight = tuple(c[c[:, :, 0].argmax()][0])
            cv2.circle(baseImage, extRight, 7, (0, 0, 255), 5)
            extTop = tuple(c[c[:, :, 1].argmin()][0])
            cv2.circle(baseImage, extTop, 7, (0, 0, 255), 5)
            extBottom = tuple(c[c[:, :, 1].argmax()][0]) 
            cv2.circle(baseImage, extBottom, 7, (0, 0, 255), 5)
            achou += 1
            #print("left:{} right:{} top:{} bottom:{}".format(extLeft, extRight, extTop, extBottom))
        except:
            pass
            #print("nao tem")
        cX, cY = 0, 0
        for c in self.filter_contours_output:
            # compute the center of the contour
            M = cv2.moments(c)
            cX = int(M["m10"] / M["m00"])
            cY = int(M["m01"] / M["m00"])
            cv2.circle(baseImage, (cX, cY), 7, (0, 0, 255), 5)
            cv2.drawContours(baseImage, self.filter_contours_output, -1, (0,255,0), 3)
            cv2.putText(baseImage, str(cX), (cX - 20, cY - 20),
                cv2.FONT_HERSHEY_SIMPLEX, 3, (0, 0, 255), 2)
            cv2.putText(baseImage, str(cY), (cX + 20, cY - 20),
                cv2.FONT_HERSHEY_SIMPLEX, 3, (0, 0, 255), 2)
            #cv2.rectangle(baseImage, (500, 300), (700,500), (255, 0, 0), 10)
        return baseImage, self.hsv_threshold_output, cX, cY

    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy = cv2.findContours(input, mode = mode, method = method)
        return contours

    @staticmethod
    def __filter_contours(input_contours, min_area, min_perimeter, min_width, max_width,
                        min_height, max_height, solidity, max_vertex_count, min_vertex_count,
                        min_ratio, max_ratio):
        """Filters out contours that do not meet certain criteria.
        Args:
            input_contours: Contours as a list of numpy.ndarray.
            min_area: The minimum area of a contour that will be kept.
            min_perimeter: The minimum perimeter of a contour that will be kept.
            min_width: Minimum width of a contour.
            max_width: MaxWidth maximum width.
            min_height: Minimum height.
            max_height: Maximimum height.
            solidity: The minimum and maximum solidity of a contour.
            min_vertex_count: Minimum vertex Count of the contours.
            max_vertex_count: Maximum vertex Count.
            min_ratio: Minimum ratio of width to height.
            max_ratio: Maximum ratio of width to height.
        Returns:
            Contours as a list of numpy.ndarray.
        """
        output = []
        for contour in input_contours:
            x,y,w,h = cv2.boundingRect(contour)
            if (w < min_width or w > max_width):
                continue
            if (h < min_height or h > max_height):
                continue
            area = cv2.contourArea(contour)
            if (area < min_area):
                continue
            if (cv2.arcLength(contour, True) < min_perimeter):
                continue
            hull = cv2.convexHull(contour)
            solid = 100 * area / cv2.contourArea(hull)
            if (solid < solidity[0] or solid > solidity[1]):
                continue
            if (len(contour) < min_vertex_count or len(contour) > max_vertex_count):
                continue
            ratio = (float)(w) / h
            if (ratio < min_ratio or ratio > max_ratio):
                continue
            output.append(contour)
        return output


def expo(number, times):
    x = 1
    for i in range(times):
        x*=number
    return x

def findDistance(imageHeight, parameters=0):
    parameters = [1179.9093977833322, -0.001280039613577564, 0.6326608380355377]
    # support = [imageHeight**4, imageHeight**3, imageHeight**2, imageHeight, 1]
    # distance = 0
    # for i in range(5):
    #     distance += parameters[i]*support[i]
    # return distance
    # parameters = [[0], [0], [0]]
    # parameters[0] = [1776.5900196236644, -0.00158998129500108, 1.0136829121159376]
    # parameters[1] = [1375.2775678593678, -0.0014182265240214801, 0.8607600759464676]
    # parameters[2] = [6747.5097822967155, -0.0023190368162005416, 1.8947975565541881]
    # baseDistance = parameters[0][0]/np.tan(parameters[0][1]*imageHeight+parameters[0][2])
    # if baseDistance <= 3700: 
    #    return parameters[1][0]/np.tan(parameters[1][1]*imageHeight+parameters[1][2])
    # else:
    #     return parameters[2][0]/np.tan(parameters[2][1]*imageHeight+parameters[2][2])
    # else: #4601 - 15000 millimeters
    #     parameters[4][0]/np.tan(parameters[4][1]*imageHeight+parameters[4][2])
    return parameters[0]/tan(parameters[1]*imageHeight+parameters[2])

#Returns an array [XAngle, YAngle] 
def getAngle(position, imageResolution): 
    XAngle = np.arctan((position[0] - (imageResolution[0]-1)/2)/focalLength)*180/np.pi
    YAngle = np.arctan((position[1] - (imageResolution[1]-1)/2)/focalLength)*180/np.pi
    angle = [XAngle, YAngle]
    return angle

# def getDistanceParameters():
#     parameters = [0,0,0]
#     try:
#         parameters[0] = netTableDistanceParameters.getDoubleArray([0, 0, 0])
#     except:
#         print("Error distance parameters")
#     return parameters

def getCameraParameters():
    try:
        focalLength = netTableFocalLength.getDouble(380.191176*2)
        cameraHeight = netTableCameraHeight.getDouble(1)
        brightness = netTableCameraBrightness.getDouble(0)
        exposure = netTableCameraExposure.getDouble(0)
    except:
        print("Error Camera parameters")

def getDistanceParameters():
    parameters = [0,0,0]
    try:
        with open('distanceParameters.json', 'r') as f:
            parameters_dict = json.load(f)
        parameters[0] = parameters_dict['A']
        parameters[1] = parameters_dict['B']
        parameters[2] = parameters_dict['C']
    except:
        print("Error distance parameters")
    return parameters


processImage = GripPipeline()
def main():
    imageResolutionRasp = [1280, 720]
    imageResolutionSend = [320, 180]

    cs = CameraServer.getInstance()
    cs.enableLogging()
    outputStreamEdited = cs.putVideo("processedImage", imageResolutionSend[0], imageResolutionSend[1])
    outputStreamBinary = cs.putVideo("binaryImage", imageResolutionSend[0], imageResolutionSend[1])
    img = np.zeros(shape=(imageResolutionRasp[1], imageResolutionRasp[0], 3), dtype=np.uint8)

    camera = UsbCamera("Camera", "/dev/video0")
    camera.setResolution(imageResolutionRasp[0], imageResolutionRasp[1])
    camera.setBrightness(brightness)
    camera.setExposureManual(exposure)
    cs.addCamera(camera)
    cvSink = cs.getVideo()
    cvSink.setSource(camera)
    tempoInicial = time.time()
    timePassed = 0
    while True:
        if(CALIBRACAO == True):
            processImage.getHSVParameters()
            getCameraParameters()
        t, img = cvSink.grabFrame(img)
        processedImage, binaryImage, objectXPos, objectYPos = processImage.process(img)
        distance = findDistance(objectYPos, getDistanceParameters())
        angle = getAngle([objectXPos, objectYPos], imageResolutionRasp)
        timeDifference = time.time() - tempoInicial
        if timeDifference > 2:
            print("Time: {} Distance: {} XPos: {} YPos: {}".format(timePassed, distance, objectXPos, objectYPos))
            print("qualidade do filtro HSV: ", achou/total*100, "%")
            tempoInicial = time.time()
            timePassed+=2

        smallerProcessedImage = cv2.resize(processedImage, (imageResolutionSend[0], imageResolutionSend[1]))
        smallerBinaryImage = cv2.resize(binaryImage, (imageResolutionSend[0], imageResolutionSend[1]))
        outputStreamEdited.putFrame(smallerProcessedImage)
        outputStreamBinary.putFrame(smallerBinaryImage)
main()
